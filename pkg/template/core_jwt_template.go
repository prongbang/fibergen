package template

type coreJwtTemplate struct {
}

func (c *coreJwtTemplate) Text() []byte {
	return []byte("package core\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/golang-jwt/jwt\"\n\t\"github.com/pkg/errors\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar DefaultExpired = time.Hour * 24\n\ntype JWTPayload struct {\n\tSub   string   `json:\"sub\"`\n\tRoles []string `json:\"roles\"`\n\tExp   int64    `json:\"exp\"`\n}\n\nfunc GetString(c *fiber.Ctx, key string) string {\n\treturn GetStringBySecret(c, key, os.Getenv(\"JWT_SECRET\"))\n}\n\nfunc GetSub(token string) string {\n\tif payload, err := getPayloadByToken(token, os.Getenv(\"JWT_SECRET\")); err == nil {\n\t\treturn payload.Sub\n\t}\n\treturn \"\"\n}\n\nfunc GetRoleId(c *fiber.Ctx) string {\n\tpayload := GetJWTPayload(c)\n\tif len(payload.Roles) > 0 {\n\t\treturn payload.Roles[0]\n\t}\n\treturn \"\"\n}\n\nfunc GetStringBySecret(c *fiber.Ctx, key string, secretKey string) string {\n\tauthorization := Authorization(c)\n\tif authorization != \"\" {\n\t\ttokenStr := strings.Replace(authorization, \"Bearer \", \"\", -1)\n\t\thmacSecret := []byte(secretKey)\n\t\ttoken, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn hmacSecret, nil\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\n\t\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\t\tuid := claims[key]\n\t\t\treturn uid.(string)\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc GetJWTPayload(c *fiber.Ctx) JWTPayload {\n\tpayload, _ := getJWTPayload(c, os.Getenv(\"JWT_SECRET\"))\n\treturn payload\n}\n\nfunc getJWTPayload(c *fiber.Ctx, secret string) (JWTPayload, error) {\n\tauthorization := Authorization(c)\n\tif authorization != \"\" {\n\t\ttokenStr := strings.Replace(authorization, \"Bearer \", \"\", -1)\n\t\treturn getPayloadByToken(tokenStr, secret)\n\t}\n\treturn JWTPayload{}, errors.New(\"Authorization is empty\")\n}\n\nfunc getPayloadByToken(tokenStr string, secret string) (JWTPayload, error) {\n\ttoken, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n\t\treturn []byte(secret), nil\n\t})\n\tif err != nil {\n\t\treturn JWTPayload{}, err\n\t}\n\tclaims, ok := token.Claims.(jwt.MapClaims)\n\tif ok && token.Valid {\n\t\tif p, err := json.Marshal(claims); err == nil {\n\t\t\tpayload := JWTPayload{}\n\t\t\tif err = json.Unmarshal(p, &payload); err == nil {\n\t\t\t\treturn payload, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn JWTPayload{}, errors.New(\"Token invalid\")\n}\n\nfunc NewClaims() jwt.MapClaims {\n\t// Create token\n\tjwtToken := jwt.New(jwt.SigningMethodHS256)\n\n\t// Set claims\n\tclaims := jwtToken.Claims.(jwt.MapClaims)\n\treturn claims\n}\n\nfunc GenerateJWT(secret string, claims map[string]interface{}) string {\n\t// Set claims\n\tpayload := jwt.MapClaims{}\n\tfor k, v := range claims {\n\t\tpayload[k] = v\n\t}\n\n\t// Generate encoded token and send it as response.\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)\n\ttokenStr, err := token.SignedString([]byte(secret))\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"Bearer %s\", tokenStr)\n}\n")
}

func CoreJwtTemplate() Template {
	return &coreJwtTemplate{}
}
